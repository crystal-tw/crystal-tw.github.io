<!DOCTYPE html>
<html lang='zh-Hant'>
  <head>
    <meta charset='utf-8'>
    <title>Auto - Crystal 程式語言 
    </title>
    <!-- Import Google Icon Font -->
    <link href='https://fonts.googleapis.com/icon?family=Material+Icons|Roboto+Mono' rel='stylesheet'>
    <link type="text/css" rel="stylesheet" href="/assets/stylesheet.css">
    <link href='/feed.xml' rel='alternate' title='Atom 1.0' type='application/atom+xml'>
    <link href='/favicon.png' rel='icon' type='image/png'>
    <link href='/favicon.ico' rel='shortcut icon' type='image/x-icon'>
    <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Auto - Crystal 程式語言</title>
<meta property="og:title" content="Auto" />
<meta name="description" content="Note: this was an April’s Fool post. However, with Crystal macros you could do this." />
<meta property="og:description" content="Note: this was an April’s Fool post. However, with Crystal macros you could do this." />
<link rel="canonical" href="http://crystal-tw.github.io/2015/04/01/auto.html" />
<meta property="og:url" content="http://crystal-tw.github.io/2015/04/01/auto.html" />
<meta property="og:site_name" content="Crystal 程式語言" />
<meta property="og:image" content="http://crystal-tw.github.io/images/icon.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-04-01T00:00:00+00:00" />
<link rel="next" href="http://crystal-tw.github.io/2015/04/30/crystal-0.7.0-released.html" title="Crystal 0.7.0 released!" />
<link rel="prev" href="http://crystal-tw.github.io/2015/03/04/internals.html" title="Internals" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@CrystalLanguage" />
<meta name="twitter:creator" content="@asterite" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Auto",
    "image": "http://crystal-tw.github.io/images/icon.png",
    "datePublished": "2015-04-01T00:00:00+00:00",
    "description": "Note: this was an April’s Fool post. However, with Crystal macros you could do this.",
    "logo": "http://crystal-tw.github.io/images/crystal-h.png",
    "url": "http://crystal-tw.github.io/2015/04/01/auto.html"
  }
</script>
<!-- End Jekyll SEO tag -->
    <!-- Let browser know website is optimized for mobile -->
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <script src='https://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript'></script>
  </head>
  <body>
    <div class="wrapper ">
      <nav role='navigation'>
  <div class='nav-wrapper no-select'>
    
      <a class='brand-logo' id='logo-container'>
        <canvas height='120' id='logo-canvas' style='cursor:move' width='120'></canvas>
      </a>
    
    <ul class='right hide-on-med-and-down' id='nav-desktop'>
      

  

  
    <li>
      <a href="/" >
        
          Home
        
      </a>
    </li>
  

  
    <li>
      <a href="/blog/" >
        
          Blog
        
      </a>
    </li>
  

  
    <li>
      <a href="/sponsors/" >
        
          Sponsors
        
      </a>
    </li>
  

  
    <li>
      <a href="/community/" >
        
          Community
        
      </a>
    </li>
  

  
    <li>
      <a href="/media/" >
        
          Media
        
      </a>
    </li>
  

<li>
  <a href='http://tw.crystal-lang.org/docs/' target="_blank">入門文件</a>
</li>
<li>
  <a href='https://crystal-lang.org/api/' target="_blank">API</a>
</li>
<li>
  <a href='https://github.com/crystal-lang/crystal' target="_blank">GitHub</a>
</li>


    </ul>
    <ul class='side-nav' id='nav-mobile'>
      

  

  
    <li>
      <a href="/" >
        
          Home
        
      </a>
    </li>
  

  
    <li>
      <a href="/blog/" >
        
          Blog
        
      </a>
    </li>
  

  
    <li>
      <a href="/sponsors/" >
        
          Sponsors
        
      </a>
    </li>
  

  
    <li>
      <a href="/community/" >
        
          Community
        
      </a>
    </li>
  

  
    <li>
      <a href="/media/" >
        
          Media
        
      </a>
    </li>
  

<li>
  <a href='http://tw.crystal-lang.org/docs/' target="_blank">入門文件</a>
</li>
<li>
  <a href='https://crystal-lang.org/api/' target="_blank">API</a>
</li>
<li>
  <a href='https://github.com/crystal-lang/crystal' target="_blank">GitHub</a>
</li>


    </ul>
    <a class='button-collapse' data-activates='nav-mobile' href='#'>
      <i class='material-icons'>menu</i>
    </a>
  </div>
</nav>

      
        <div class='post-header'>
  <div class="container">
    <div class='valign row'>
      <div class="col m2"></div>
      <div class="col s12 m9">
        <div class="author small">
          
          
            <img src="/assets/authors/asterite.jpg" width="360" height="360" alt="authors/asterite.jpg">
          
          
            <span class="author_name">Ary Borenzweig</span>
          
          
          
            <span class="date">01 Apr 2015</span>
          
        </div>

        <h1 class='title'>Auto</h1>
      </div>
      <div class="col m1"></div>
    </div>
  </div>
</div>

      
      <main>
        <div class="container">
  <div class="row post-layout">
    <div class="col m2 share">
      <p class="title small share-title">Share</p>
      <div class="share-list">
        
        <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2F127.0.0.1%2F2015%2F04%2F01%2Fauto.html&text=Auto&via=CrystalLanguage" target="_blank">
          <div class="share-item"><i class="extra-icons twitter gray"></i></div>
        </a>
        <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2F127.0.0.1%2F2015%2F04%2F01%2Fauto.html" target="_blank">
          <div class="share-item"><i class="extra-icons facebook gray"></i></div>
        </a>
        <a href="https://plus.google.com/share?url=https%3A%2F%2F127.0.0.1%2F2015%2F04%2F01%2Fauto.html" target="_blank">
          <div class="share-item"><i class="extra-icons google_plus gray"></i></div>
          </a>
      </div>
    </div>

    <div class="col s12 m9">
      <p><strong>Note: this was an April’s Fool post. However, with Crystal macros you could do this.</strong></p>

<p>We Crystal developers believe compilers should be smart. You don’t need to add type annotations everywhere:
only when needed, or when you want them. Can we make the compiler even smarter?</p>

<p>This past month we have been thinking that since Crystal is a relatively young language with a still
incomplete standard library and ecosystem, there are lots of things to code yet. It’s unfortunate
that many of these algorithms and data structures are already present in other languages. Not only that,
but these other languages have been used for many years now, so their implementation is pretty robust and
bug free. We will have to walk the same road in Crystal. Or will we?</p>

<p>Well, not anymore. The next release of Crystal will have a tiny but powerful addition: an <strong>auto</strong> keyword.
To understand how it works, let’s see it in action:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">String</span>
  <span class="n">auto</span> <span class="k">def</span> <span class="nf">succ</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="s2">"hello"</span><span class="p">.</span><span class="nf">succ</span> <span class="c1">#=&gt; "hellp"</span></code></pre></figure>
</div>

<p>The first thing you need to know is that <code class="highlighter-rouge">String#succ</code> is not in Crystal’s standard library. In the code
above we define it with the <strong>auto</strong> keyword, leaving the body empty. We then invoke the method on some
string and it gives the correct value. Awesome! Crystal not only deduced the return type of <code class="highlighter-rouge">succ</code>,
it also deduced its <em>behaviour</em>!</p>

<h2 id="how-auto-is-implemented">How <strong>auto</strong> is implemented</h2>

<p>When we said <strong>auto</strong> is a keyword, we lied: it’s a macro. Macros in Crystal receive AST nodes, that is,
they receive syntax. <strong>auto</strong> then receives a method definition and processes it at compile-time to generate
a method definition that implements the desired functionality:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">macro</span> <span class="n">auto</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span></code></pre></figure>
</div>

<p>Macros can inspect the arguments: they can ask the method’s name, arguments or where the method is defined
(String in the above example). If you need to do more complex stuff, you can invoke <strong>run</strong> in a macro,
like this:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">macro</span> <span class="n">auto</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
  <span class="p">{{</span> <span class="n">run</span><span class="p">(</span><span class="s2">"auto/process"</span><span class="p">,</span> <span class="vi">@type</span><span class="p">,</span> <span class="nb">method</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="o">*</span><span class="nb">method</span><span class="p">.</span><span class="nf">args</span><span class="p">)</span> <span class="p">}}</span>
<span class="k">end</span></code></pre></figure>
</div>

<p>This will invoke the program <code class="highlighter-rouge">auto/process.cr</code> passing the type name, method name and splatted method arguments
to the program. The program then receives these arguments in the usual <code class="highlighter-rouge">ARGV</code> array, processes them and
outputs a method definition that will then be embedded in our original program. Neat, right? We use a similar
technique for ECR (similar to ERB): the ECR templates are processed at compile-time.</p>

<p>The <code class="highlighter-rouge">auto/process.cr</code> program does a few things: it searches the internet for relevant method definitions together
with their source code and possibly associated tests/specs. Right now this is only done for Ruby code because
of its similarity with Crystal, but support for other languages is coming soon.
Then it processes the code and generates Crystal code.</p>

<p>Now, this can be quite slow. In fact, it takes a few seconds (5 seconds on one of our machines). Luckily, the
generated code is cached in the usual “.crystal” directory so the next time <strong>auto</strong> is used for the same
method of a same type, it will reuse the cached version. But even with this penalty, think of the time
you save by using <strong>auto</strong>: you don’t have to write the method, plus you reuse existing robust and well-tested
code!</p>

<h2 id="auto-types"><strong>auto</strong> types</h2>

<p>You can even use <strong>auto</strong> on a type:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">auto</span> <span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="no">T</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">list</span> <span class="o">=</span> <span class="no">LinkedList</span><span class="p">(</span><span class="no">Char</span><span class="p">).</span><span class="nf">new</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'a'</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'b'</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'c'</span>
<span class="nb">puts</span> <span class="n">list</span><span class="p">.</span><span class="nf">size</span> <span class="c1">#=&gt; 3</span>
<span class="nb">puts</span> <span class="n">list</span>        <span class="c1">#=&gt; ['a', 'b', 'c']</span></code></pre></figure>
</div>

<p>So the <strong>auto</strong> macro actually checks whether the received AST node is a class or method. For the class
case, <code class="highlighter-rouge">auto/process.cr</code> will search that class name on the internet and generate a definition for it
together with every method it can find for it, reusing the previous logic.</p>

<h2 id="trying-it">Trying it</h2>

<p>You can try all of this by checking out the <a href="https://github.com/crystal-lang/crystal/commit/46fd17de4964e648192c1f9c8a039088f6520cb0">auto branch</a> in our GitHub repository, but you’ll need
to compile a new compiler because we added some macro methods for this feature. Please understand
that this is still very new so any bug you find, please report it!</p>

    </div>
    <div class="col m1"></div>
  </div>

  <div class="row disqus">
    <div class="col m2"></div>
    <div class="col s12 m9" id='disqus_thread'>
      <p><strong>Note: this was an April’s Fool post. However, with Crystal macros you could do this.</strong></p>

<p>We Crystal developers believe compilers should be smart. You don’t need to add type annotations everywhere:
only when needed, or when you want them. Can we make the compiler even smarter?</p>

<p>This past month we have been thinking that since Crystal is a relatively young language with a still
incomplete standard library and ecosystem, there are lots of things to code yet. It’s unfortunate
that many of these algorithms and data structures are already present in other languages. Not only that,
but these other languages have been used for many years now, so their implementation is pretty robust and
bug free. We will have to walk the same road in Crystal. Or will we?</p>

<p>Well, not anymore. The next release of Crystal will have a tiny but powerful addition: an <strong>auto</strong> keyword.
To understand how it works, let’s see it in action:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">String</span>
  <span class="n">auto</span> <span class="k">def</span> <span class="nf">succ</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="s2">"hello"</span><span class="p">.</span><span class="nf">succ</span> <span class="c1">#=&gt; "hellp"</span></code></pre></figure>
</div>

<p>The first thing you need to know is that <code class="highlighter-rouge">String#succ</code> is not in Crystal’s standard library. In the code
above we define it with the <strong>auto</strong> keyword, leaving the body empty. We then invoke the method on some
string and it gives the correct value. Awesome! Crystal not only deduced the return type of <code class="highlighter-rouge">succ</code>,
it also deduced its <em>behaviour</em>!</p>

<h2 id="how-auto-is-implemented">How <strong>auto</strong> is implemented</h2>

<p>When we said <strong>auto</strong> is a keyword, we lied: it’s a macro. Macros in Crystal receive AST nodes, that is,
they receive syntax. <strong>auto</strong> then receives a method definition and processes it at compile-time to generate
a method definition that implements the desired functionality:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">macro</span> <span class="n">auto</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span></code></pre></figure>
</div>

<p>Macros can inspect the arguments: they can ask the method’s name, arguments or where the method is defined
(String in the above example). If you need to do more complex stuff, you can invoke <strong>run</strong> in a macro,
like this:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">macro</span> <span class="n">auto</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
  <span class="p">{{</span> <span class="n">run</span><span class="p">(</span><span class="s2">"auto/process"</span><span class="p">,</span> <span class="vi">@type</span><span class="p">,</span> <span class="nb">method</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="o">*</span><span class="nb">method</span><span class="p">.</span><span class="nf">args</span><span class="p">)</span> <span class="p">}}</span>
<span class="k">end</span></code></pre></figure>
</div>

<p>This will invoke the program <code class="highlighter-rouge">auto/process.cr</code> passing the type name, method name and splatted method arguments
to the program. The program then receives these arguments in the usual <code class="highlighter-rouge">ARGV</code> array, processes them and
outputs a method definition that will then be embedded in our original program. Neat, right? We use a similar
technique for ECR (similar to ERB): the ECR templates are processed at compile-time.</p>

<p>The <code class="highlighter-rouge">auto/process.cr</code> program does a few things: it searches the internet for relevant method definitions together
with their source code and possibly associated tests/specs. Right now this is only done for Ruby code because
of its similarity with Crystal, but support for other languages is coming soon.
Then it processes the code and generates Crystal code.</p>

<p>Now, this can be quite slow. In fact, it takes a few seconds (5 seconds on one of our machines). Luckily, the
generated code is cached in the usual “.crystal” directory so the next time <strong>auto</strong> is used for the same
method of a same type, it will reuse the cached version. But even with this penalty, think of the time
you save by using <strong>auto</strong>: you don’t have to write the method, plus you reuse existing robust and well-tested
code!</p>

<h2 id="auto-types"><strong>auto</strong> types</h2>

<p>You can even use <strong>auto</strong> on a type:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">auto</span> <span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="no">T</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">list</span> <span class="o">=</span> <span class="no">LinkedList</span><span class="p">(</span><span class="no">Char</span><span class="p">).</span><span class="nf">new</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'a'</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'b'</span>
<span class="n">list</span><span class="p">.</span><span class="nf">push</span> <span class="s1">'c'</span>
<span class="nb">puts</span> <span class="n">list</span><span class="p">.</span><span class="nf">size</span> <span class="c1">#=&gt; 3</span>
<span class="nb">puts</span> <span class="n">list</span>        <span class="c1">#=&gt; ['a', 'b', 'c']</span></code></pre></figure>
</div>

<p>So the <strong>auto</strong> macro actually checks whether the received AST node is a class or method. For the class
case, <code class="highlighter-rouge">auto/process.cr</code> will search that class name on the internet and generate a definition for it
together with every method it can find for it, reusing the previous logic.</p>

<h2 id="trying-it">Trying it</h2>

<p>You can try all of this by checking out the <a href="https://github.com/crystal-lang/crystal/commit/46fd17de4964e648192c1f9c8a039088f6520cb0">auto branch</a> in our GitHub repository, but you’ll need
to compile a new compiler because we added some macro methods for this feature. Please understand
that this is still very new so any bug you find, please report it!</p>

    </div>
    <div class="col m1"></div>
  </div>
</div>
<script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'crystal-lang'; // required: replace example with your forum shortname
  var disqus_identifier = '/2015/04/01/auto';
  var disqus_title = "Auto";
  var disqus_url = "http://crystal-lang.org//2015/04/01/auto.html";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a>
</noscript>
<a class='dsq-brlink' href='http://disqus.com'>
  comments powered by
  <span class='logo-disqus'>Disqus</span>
</a>

      </main>
      <footer>
  <div class="row">
    <div class="col s12 m12 l6 crystal" style="margin-top: -.5em;">
      Crystal is licensed under the Apache License,
      <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>
        Version 2.0
      </a>
			<br />
			本站正體中文（臺灣）翻譯由 
			<a href='https://github.com/crystal-tw' target='_blank'>
				Crystal-TW
			</a>
			社群貢獻。
    </div>
    <div class="col s12 m12 l6 manas right-align black-text">
      Crystal language, born &amp; raised at
      <a href="https://manas.tech" target="_blank" class="black-text">Manas</a>
      <a href="https://manas.tech" target="_blank" class="logo">
        <i class="manas"></i>
      </a>
    </div>
  </div>
</footer>

    </div>

    <script id="dsq-count-scr" src="//crystal-lang.disqus.com/count.js" async></script>
    <script type="text/javascript" src="/assets/bundle.js"></script>
    <!-- Disable original GA temporary
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42353458-1', 'auto');
  ga('send', 'pageview');
</script>
-->

  </body>
</html>
