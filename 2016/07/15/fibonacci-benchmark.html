<!DOCTYPE html>
<html lang='zh-Hant'>
  <head>
    <meta charset='utf-8'>
    <title>Fibonacci benchmark - Crystal 程式語言 
    </title>
    <!-- Import Google Icon Font -->
    <link href='https://fonts.googleapis.com/icon?family=Material+Icons|Roboto+Mono' rel='stylesheet'>
    <link type="text/css" rel="stylesheet" href="/assets/stylesheet.css">
    <link href='/feed.xml' rel='alternate' title='Atom 1.0' type='application/atom+xml'>
    <link href='/favicon.png' rel='icon' type='image/png'>
    <link href='/favicon.ico' rel='shortcut icon' type='image/x-icon'>
    <!-- Begin Jekyll SEO tag v1.4.0 -->
<title>Fibonacci benchmark - Crystal 程式語言</title>
<meta property="og:title" content="Fibonacci benchmark" />
<meta name="description" content="When trying out Crystal it’s tempting, and very fun, to write small benchmarks to seehow the language’s performance compares to other languages. Because of its syntax,comparing with Ruby is usually the simplest thing to do. Many times we can evenuse the same code." />
<meta property="og:description" content="When trying out Crystal it’s tempting, and very fun, to write small benchmarks to seehow the language’s performance compares to other languages. Because of its syntax,comparing with Ruby is usually the simplest thing to do. Many times we can evenuse the same code." />
<link rel="canonical" href="http://crystal-tw.github.io/2016/07/15/fibonacci-benchmark.html" />
<meta property="og:url" content="http://crystal-tw.github.io/2016/07/15/fibonacci-benchmark.html" />
<meta property="og:site_name" content="Crystal 程式語言" />
<meta property="og:image" content="http://crystal-tw.github.io/images/icon.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-15T00:00:00+00:00" />
<link rel="next" href="http://crystal-tw.github.io/2016/09/09/a-story-of-compromises-and-types.html" title="A story of compromises and types" />
<link rel="prev" href="http://crystal-tw.github.io/2016/06/28/split-the-repo.html" title="Split the repo!" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@CrystalLanguage" />
<meta name="twitter:creator" content="@asterite" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Fibonacci benchmark",
    "image": "http://crystal-tw.github.io/images/icon.png",
    "datePublished": "2016-07-15T00:00:00+00:00",
    "description": "When trying out Crystal it’s tempting, and very fun, to write small benchmarks to seehow the language’s performance compares to other languages. Because of its syntax,comparing with Ruby is usually the simplest thing to do. Many times we can evenuse the same code.",
    "logo": "http://crystal-tw.github.io/images/crystal-h.png",
    "url": "http://crystal-tw.github.io/2016/07/15/fibonacci-benchmark.html"
  }
</script>
<!-- End Jekyll SEO tag -->
    <!-- Let browser know website is optimized for mobile -->
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <script src='https://code.jquery.com/jquery-3.1.1.min.js' type='text/javascript'></script>
  </head>
  <body>
    <div class="wrapper ">
      <nav role='navigation'>
  <div class='nav-wrapper no-select'>
    
      <a class='brand-logo' id='logo-container'>
        <canvas height='120' id='logo-canvas' style='cursor:move' width='120'></canvas>
      </a>
    
    <ul class='right hide-on-med-and-down' id='nav-desktop'>
      

  

  
    <li>
      <a href="/" >
        
          Home
        
      </a>
    </li>
  

  
    <li>
      <a href="/blog/" >
        
          Blog
        
      </a>
    </li>
  

  
    <li>
      <a href="/sponsors/" >
        
          Sponsors
        
      </a>
    </li>
  

  
    <li>
      <a href="/community/" >
        
          Community
        
      </a>
    </li>
  

  
    <li>
      <a href="/media/" >
        
          Media
        
      </a>
    </li>
  

<li>
  <a href='http://tw.crystal-lang.org/docs/' target="_blank">入門文件</a>
</li>
<li>
  <a href='https://crystal-lang.org/api/' target="_blank">API</a>
</li>
<li>
  <a href='https://github.com/crystal-lang/crystal' target="_blank">GitHub</a>
</li>


    </ul>
    <ul class='side-nav' id='nav-mobile'>
      

  

  
    <li>
      <a href="/" >
        
          Home
        
      </a>
    </li>
  

  
    <li>
      <a href="/blog/" >
        
          Blog
        
      </a>
    </li>
  

  
    <li>
      <a href="/sponsors/" >
        
          Sponsors
        
      </a>
    </li>
  

  
    <li>
      <a href="/community/" >
        
          Community
        
      </a>
    </li>
  

  
    <li>
      <a href="/media/" >
        
          Media
        
      </a>
    </li>
  

<li>
  <a href='http://tw.crystal-lang.org/docs/' target="_blank">入門文件</a>
</li>
<li>
  <a href='https://crystal-lang.org/api/' target="_blank">API</a>
</li>
<li>
  <a href='https://github.com/crystal-lang/crystal' target="_blank">GitHub</a>
</li>


    </ul>
    <a class='button-collapse' data-activates='nav-mobile' href='#'>
      <i class='material-icons'>menu</i>
    </a>
  </div>
</nav>

      
        <div class='post-header'>
  <div class="container">
    <div class='valign row'>
      <div class="col m2"></div>
      <div class="col s12 m9">
        <div class="author small">
          
          
            <img src="/assets/authors/asterite.jpg" width="360" height="360" alt="authors/asterite.jpg">
          
          
            <span class="author_name">Ary Borenzweig</span>
          
          
          
            <span class="date">15 Jul 2016</span>
          
        </div>

        <h1 class='title'>Fibonacci benchmark</h1>
      </div>
      <div class="col m1"></div>
    </div>
  </div>
</div>

      
      <main>
        <div class="container">
  <div class="row post-layout">
    <div class="col m2 share">
      <p class="title small share-title">Share</p>
      <div class="share-list">
        
        <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2F127.0.0.1%2F2016%2F07%2F15%2Ffibonacci-benchmark.html&text=Fibonacci+benchmark&via=CrystalLanguage" target="_blank">
          <div class="share-item"><i class="extra-icons twitter gray"></i></div>
        </a>
        <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2F127.0.0.1%2F2016%2F07%2F15%2Ffibonacci-benchmark.html" target="_blank">
          <div class="share-item"><i class="extra-icons facebook gray"></i></div>
        </a>
        <a href="https://plus.google.com/share?url=https%3A%2F%2F127.0.0.1%2F2016%2F07%2F15%2Ffibonacci-benchmark.html" target="_blank">
          <div class="share-item"><i class="extra-icons google_plus gray"></i></div>
          </a>
      </div>
    </div>

    <div class="col s12 m9">
      <p>When trying out Crystal it’s tempting, and very fun, to write small benchmarks to see
how the language’s performance compares to other languages. Because of its syntax,
comparing with Ruby is usually the simplest thing to do. Many times we can even
use the same code.</p>

<p>Let’s compare the fibonacci function:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fib.cr</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Let’s compare the times.</p>

<pre>
$ ruby fib.cr
433494437
37.105234
$ crystal fib.cr --release
433494437
00:00:00.9999380
</pre>

<p>As can be seen, Crystal is giving us a huge increase in performance. Nice!</p>

<p>However, there’s a fundamental problem in the above benchmark:
we aren’t comparing the same function, the same algorithm.</p>

<p>To see that this is true, let’s try increasing the number 42 to 46 and run
the programs again:</p>

<pre>
$ ruby fib.cr
2971215073
260.206918
$ crystal fib.cr --release
-1323752223
00:00:06.8042220
</pre>

<p>What did just happen?</p>

<p>It turns out Crystal has several integer types that map to a computer’s integers:
Int8 for signed numbers represented with 8 bits, Int32 for signed numbers represented
with 32 bits, UInt64 for unsigned numbers represented with 64 bits and so on. The
default type of an integer literal in Crystal is Int32, so its maximum value is
<code class="highlighter-rouge">(2 ** 31) - 1 == 2147483647</code>. Because <code class="highlighter-rouge">2971215073</code> is bigger than this, the operation
overflows and gives a negative result.</p>

<p>Ruby, on the other hand, has two integer types: Fixnum and Bignum (although <a href="https://bugs.ruby-lang.org/issues/12005">in Ruby
2.4 they will be unified</a> in a single Integer class).
Ruby tries to represent integers with 64 bits if the are “small”
(<a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum">less than 4611686018427387903</a>),
trying not to allocate heap memory, and will use heap memory to represent integers larger than
that. When doing operations between integers, Ruby will make sure to create a Bignum in case
of overflow, to give a correct result.</p>

<p>Now we can understand why Ruby is slower: it has to do this overflow check on every operation,
preventing some optimizations. Crystal, on the other hand, can ask LLVM to optimize this code
very well, sometimes even letting LLVM compute the result at compile time. However, Crystal
might give incorrect results, while Ruby makes sure to always give the correct result.</p>

<p>In my opinion, Ruby’s philosophy is, whenever there’s a choice between correct behavior and
good performance, to favor correct behaviour. One can see this in this small example:</p>

<pre>
$ irb
irb(main):001:0&gt; a = []
=&gt; []
irb(main):002:0&gt; a &lt;&lt; a
=&gt; [[...]]
</pre>

<p>Note that when printing an array, Ruby notices that it reached the same array it was printing,
so it printed <code class="highlighter-rouge">[...]</code> to show this. The program didn’t hang up, recurisvely trying to print the
same array over and over. To implement this, Ruby has to remember that this Array is being printed,
probably putting it in a Hash of some sort, and when printing an object inside this Array a hash
lookup is performed.</p>

<p>The same happens when you inspect an object, and the object has a reference to itself:</p>

<pre>
irb(main):001:0&gt; class Foo
irb(main):002:1&gt;   def initialize
irb(main):003:2&gt;     @self = self
irb(main):004:2&gt;   end
irb(main):005:1&gt; end
=&gt; :initialize
irb(main):006:0&gt; Foo.new
=&gt; #&lt;Foo:0x007fc7429bbe30 @self=#&lt;Foo:0x007fc7429bbe30 ...&gt;&gt;
</pre>

<p>These subtleties aren’t immediately visible in Ruby, but once you discover them they make
you have a profound respect for Matz and his team.</p>

<p>These choices have an impact on performance, though. If we’d like Crystal to give the correct
result to <code class="highlighter-rouge">fib</code>, like in Ruby, we would have to sacrifice some performance. However, Crystal
makes this decision because doing big numbers math, and checking overflows all the time,
affects every part of a program. For example, there’s a CPU instruction to increment a number
by one, and Crystal can take advantage of it. Ruby probably can’t, because it also needs
to check for overflow.</p>

<p>There is, however, a way to get the correct result in Crystal, and this is similar to other languages:
explicitly use big numbers. Let’s do it:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Let’s run it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:02:28.8212840
</pre>

<p>Now we get the correct result, but note that this is about 4~5 times slower than Ruby.
Why?</p>

<p>I don’t know the answer, but I have some guesses. Maybe Ruby’s Bignum implementation is
more efficient than LibGMP, the library we are using for BigInt.
Maybe Ruby’s GC is better than the GC we are currently using, which isn’t precise.
Maybe Ruby has some specific optimizations for these scenarios. In any case, I feel
a profound respect for Ruby, again.</p>

<p>Can we improve the performance of <code class="highlighter-rouge">fib</code> to match that of Ruby? We can try. One simple
thing is to use an iterative method, instead of doing it recursively, to avoid
creating too many BigInt instances. Let’s try:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:00:00.0006460
</pre>

<p>Much better! And way faster than Ruby. But, of course, we are cheating because Ruby still
uses the old, slow algorithm. So to be fair, we must update our Ruby implementation:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ ruby fib.rb
433494437
3.6e-05
</pre>

<p>Ruby is still faster than Crystal in this case, maybe because no Bignum was created in this
case.</p>

<p>Is there something else we can do?</p>

<p>Yes. Crystal’s <code class="highlighter-rouge">BigInt</code> is currently immutable, but maybe it could be changed to be mutable,
and be used like this for scenarios where performance of these operations is super important,
or a bottleneck in the program. Let’s reopen Crystal’s BigInt and make some changes:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="n">struct</span> <span class="no">BigInt</span>
  <span class="k">def</span> <span class="nf">add!</span><span class="p">(</span><span class="n">other</span> <span class="p">:</span> <span class="no">BigInt</span><span class="p">)</span> <span class="p">:</span> <span class="no">BigInt</span>
    <span class="no">LibGMP</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">add!</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:00:00.0006910
</pre>

<p>Hmmm… it didn’t change much. But if we try with a bigger number, say 300_000, these are the times:</p>

<pre>
$ ruby fib.rb
# number ommited
1.880515
$ crystal fib.cr --release
# number ommited
00:00:00.7621470
</pre>

<p>It seems that with big numbers, and avoiding creating multiple BigInt instance, Crystal performs
a bit better than Ruby in this case.</p>

<p>Can we make Ruby faster? I don’t know. At least Ruby’s API doesn’t allow mutating a Bignum,
so at least now there’s nothing that can be done. But since the performance is already quite
good, maybe there’s no need to improve anything in the first place.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There are several conclusions to this blog post.</p>

<p>First, Ruby is just awesome. It strives to give you correct results, and it does so with a reasonable
performance. <i>Chapeau!</i></p>

<p>Second, be careful with benchmarks: make sure you are benchmarking the same algorithm, and, if possible,
try to explain why there’s a possible difference in times (or memory usage) between languages, codes, frameworks, etc.</p>

<p>Third, Crystal lets you be very performant, but it requires more work from you, the programmer.
This is a difference from Ruby. However, Crystal tries to keep almost the same developer happiness
that Ruby gives you: it might make you feel sad or angry writing <code class="highlighter-rouge">BigInt.new(1)</code>, but this is
compensated with the happiness you get when you run your code and see it executes very fast.</p>

    </div>
    <div class="col m1"></div>
  </div>

  <div class="row disqus">
    <div class="col m2"></div>
    <div class="col s12 m9" id='disqus_thread'>
      <p>When trying out Crystal it’s tempting, and very fun, to write small benchmarks to see
how the language’s performance compares to other languages. Because of its syntax,
comparing with Ruby is usually the simplest thing to do. Many times we can even
use the same code.</p>

<p>Let’s compare the fibonacci function:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fib.cr</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Let’s compare the times.</p>

<pre>
$ ruby fib.cr
433494437
37.105234
$ crystal fib.cr --release
433494437
00:00:00.9999380
</pre>

<p>As can be seen, Crystal is giving us a huge increase in performance. Nice!</p>

<p>However, there’s a fundamental problem in the above benchmark:
we aren’t comparing the same function, the same algorithm.</p>

<p>To see that this is true, let’s try increasing the number 42 to 46 and run
the programs again:</p>

<pre>
$ ruby fib.cr
2971215073
260.206918
$ crystal fib.cr --release
-1323752223
00:00:06.8042220
</pre>

<p>What did just happen?</p>

<p>It turns out Crystal has several integer types that map to a computer’s integers:
Int8 for signed numbers represented with 8 bits, Int32 for signed numbers represented
with 32 bits, UInt64 for unsigned numbers represented with 64 bits and so on. The
default type of an integer literal in Crystal is Int32, so its maximum value is
<code class="highlighter-rouge">(2 ** 31) - 1 == 2147483647</code>. Because <code class="highlighter-rouge">2971215073</code> is bigger than this, the operation
overflows and gives a negative result.</p>

<p>Ruby, on the other hand, has two integer types: Fixnum and Bignum (although <a href="https://bugs.ruby-lang.org/issues/12005">in Ruby
2.4 they will be unified</a> in a single Integer class).
Ruby tries to represent integers with 64 bits if the are “small”
(<a href="http://patshaughnessy.net/2014/1/9/how-big-is-a-bignum">less than 4611686018427387903</a>),
trying not to allocate heap memory, and will use heap memory to represent integers larger than
that. When doing operations between integers, Ruby will make sure to create a Bignum in case
of overflow, to give a correct result.</p>

<p>Now we can understand why Ruby is slower: it has to do this overflow check on every operation,
preventing some optimizations. Crystal, on the other hand, can ask LLVM to optimize this code
very well, sometimes even letting LLVM compute the result at compile time. However, Crystal
might give incorrect results, while Ruby makes sure to always give the correct result.</p>

<p>In my opinion, Ruby’s philosophy is, whenever there’s a choice between correct behavior and
good performance, to favor correct behaviour. One can see this in this small example:</p>

<pre>
$ irb
irb(main):001:0&gt; a = []
=&gt; []
irb(main):002:0&gt; a &lt;&lt; a
=&gt; [[...]]
</pre>

<p>Note that when printing an array, Ruby notices that it reached the same array it was printing,
so it printed <code class="highlighter-rouge">[...]</code> to show this. The program didn’t hang up, recurisvely trying to print the
same array over and over. To implement this, Ruby has to remember that this Array is being printed,
probably putting it in a Hash of some sort, and when printing an object inside this Array a hash
lookup is performed.</p>

<p>The same happens when you inspect an object, and the object has a reference to itself:</p>

<pre>
irb(main):001:0&gt; class Foo
irb(main):002:1&gt;   def initialize
irb(main):003:2&gt;     @self = self
irb(main):004:2&gt;   end
irb(main):005:1&gt; end
=&gt; :initialize
irb(main):006:0&gt; Foo.new
=&gt; #&lt;Foo:0x007fc7429bbe30 @self=#&lt;Foo:0x007fc7429bbe30 ...&gt;&gt;
</pre>

<p>These subtleties aren’t immediately visible in Ruby, but once you discover them they make
you have a profound respect for Matz and his team.</p>

<p>These choices have an impact on performance, though. If we’d like Crystal to give the correct
result to <code class="highlighter-rouge">fib</code>, like in Ruby, we would have to sacrifice some performance. However, Crystal
makes this decision because doing big numbers math, and checking overflows all the time,
affects every part of a program. For example, there’s a CPU instruction to increment a number
by one, and Crystal can take advantage of it. Ruby probably can’t, because it also needs
to check for overflow.</p>

<p>There is, however, a way to get the correct result in Crystal, and this is similar to other languages:
explicitly use big numbers. Let’s do it:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
    <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Let’s run it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:02:28.8212840
</pre>

<p>Now we get the correct result, but note that this is about 4~5 times slower than Ruby.
Why?</p>

<p>I don’t know the answer, but I have some guesses. Maybe Ruby’s Bignum implementation is
more efficient than LibGMP, the library we are using for BigInt.
Maybe Ruby’s GC is better than the GC we are currently using, which isn’t precise.
Maybe Ruby has some specific optimizations for these scenarios. In any case, I feel
a profound respect for Ruby, again.</p>

<p>Can we improve the performance of <code class="highlighter-rouge">fib</code> to match that of Ruby? We can try. One simple
thing is to use an iterative method, instead of doing it recursively, to avoid
creating too many BigInt instances. Let’s try:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:00:00.0006460
</pre>

<p>Much better! And way faster than Ruby. But, of course, we are cheating because Ruby still
uses the old, slow algorithm. So to be fair, we must update our Ruby implementation:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ ruby fib.rb
433494437
3.6e-05
</pre>

<p>Ruby is still faster than Crystal in this case, maybe because no Bignum was created in this
case.</p>

<p>Is there something else we can do?</p>

<p>Yes. Crystal’s <code class="highlighter-rouge">BigInt</code> is currently immutable, but maybe it could be changed to be mutable,
and be used like this for scenarios where performance of these operations is super important,
or a bottleneck in the program. Let’s reopen Crystal’s BigInt and make some changes:</p>

<div class="code_section">
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"big"</span>

<span class="n">struct</span> <span class="no">BigInt</span>
  <span class="k">def</span> <span class="nf">add!</span><span class="p">(</span><span class="n">other</span> <span class="p">:</span> <span class="no">BigInt</span><span class="p">)</span> <span class="p">:</span> <span class="no">BigInt</span>
    <span class="no">LibGMP</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="no">BigInt</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">n</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">a</span><span class="p">.</span><span class="nf">add!</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
  <span class="k">end</span>
  <span class="n">a</span>
<span class="k">end</span>

<span class="n">time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="nb">puts</span> <span class="n">fib</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">puts</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">time</span></code></pre></figure>
</div>

<p>Running it:</p>

<pre>
$ crystal fib.cr --release
433494437
00:00:00.0006910
</pre>

<p>Hmmm… it didn’t change much. But if we try with a bigger number, say 300_000, these are the times:</p>

<pre>
$ ruby fib.rb
# number ommited
1.880515
$ crystal fib.cr --release
# number ommited
00:00:00.7621470
</pre>

<p>It seems that with big numbers, and avoiding creating multiple BigInt instance, Crystal performs
a bit better than Ruby in this case.</p>

<p>Can we make Ruby faster? I don’t know. At least Ruby’s API doesn’t allow mutating a Bignum,
so at least now there’s nothing that can be done. But since the performance is already quite
good, maybe there’s no need to improve anything in the first place.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There are several conclusions to this blog post.</p>

<p>First, Ruby is just awesome. It strives to give you correct results, and it does so with a reasonable
performance. <i>Chapeau!</i></p>

<p>Second, be careful with benchmarks: make sure you are benchmarking the same algorithm, and, if possible,
try to explain why there’s a possible difference in times (or memory usage) between languages, codes, frameworks, etc.</p>

<p>Third, Crystal lets you be very performant, but it requires more work from you, the programmer.
This is a difference from Ruby. However, Crystal tries to keep almost the same developer happiness
that Ruby gives you: it might make you feel sad or angry writing <code class="highlighter-rouge">BigInt.new(1)</code>, but this is
compensated with the happiness you get when you run your code and see it executes very fast.</p>

    </div>
    <div class="col m1"></div>
  </div>
</div>
<script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'crystal-lang'; // required: replace example with your forum shortname
  var disqus_identifier = '/2016/07/15/fibonacci-benchmark';
  var disqus_title = "Fibonacci benchmark";
  var disqus_url = "http://crystal-lang.org//2016/07/15/fibonacci-benchmark.html";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
  Please enable JavaScript to view the
  <a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a>
</noscript>
<a class='dsq-brlink' href='http://disqus.com'>
  comments powered by
  <span class='logo-disqus'>Disqus</span>
</a>

      </main>
      <footer>
  <div class="row">
    <div class="col s12 m12 l6 crystal" style="margin-top: -.5em;">
      Crystal is licensed under the Apache License,
      <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>
        Version 2.0
      </a>
			<br />
			本站正體中文（臺灣）翻譯由 
			<a href='https://github.com/crystal-tw' target='_blank'>
				Crystal-TW
			</a>
			社群貢獻。
    </div>
    <div class="col s12 m12 l6 manas right-align black-text">
      Crystal language, born &amp; raised at
      <a href="https://manas.tech" target="_blank" class="black-text">Manas</a>
      <a href="https://manas.tech" target="_blank" class="logo">
        <i class="manas"></i>
      </a>
    </div>
  </div>
</footer>

    </div>

    <script id="dsq-count-scr" src="//crystal-lang.disqus.com/count.js" async></script>
    <script type="text/javascript" src="/assets/bundle.js"></script>
    <!-- Disable original GA temporary
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42353458-1', 'auto');
  ga('send', 'pageview');
</script>
-->

  </body>
</html>
